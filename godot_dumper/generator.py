"""
SDK 生成模块
"""

from .constants import get_cpp_type


def generate_hpp(classes: dict) -> str:
    """
    生成 C++ SDK 头文件
    
    Args:
        classes: 类信息字典
        
    Returns:
        str: C++ 头文件内容
    """
    lines = []
    lines.append("// Auto-generated Godot SDK Header")
    lines.append("// Generated by godot_auto_dumper")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <cstdint>")
    lines.append("")
    lines.append("namespace Godot {")
    lines.append("")
    
    # 前向声明
    lines.append("// Forward declarations")
    for name in sorted(classes.keys()):
        lines.append(f"class {name};")
    lines.append("")
    
    # 按继承深度排序
    def get_depth(name: str, depth: int = 0) -> int:
        if name not in classes:
            return depth
        parent = classes[name].get('parent')
        if parent and parent in classes:
            return get_depth(parent, depth + 1)
        return depth
    
    sorted_classes = sorted(classes.keys(), key=lambda x: (get_depth(x), x))
    
    # 生成类定义
    for class_name in sorted_classes:
        cls = classes[class_name]
        parent = cls.get('parent')
        methods = cls.get('methods', [])
        properties = cls.get('properties', [])
        
        # 类声明
        if parent and parent in classes:
            lines.append(f"class {class_name} : public {parent} {{")
        else:
            lines.append(f"class {class_name} {{")
        
        lines.append("public:")
        
        # 属性
        if properties:
            lines.append("    // Properties")
            sorted_props = sorted(properties, key=lambda x: x.get('offset', 0))
            
            # 计算对齐
            max_decl_len = 0
            for prop in sorted_props:
                cpp_type = get_cpp_type(prop['type'])
                decl = f"{cpp_type} {prop['name']};"
                max_decl_len = max(max_decl_len, len(decl))
            
            for prop in sorted_props:
                cpp_type = get_cpp_type(prop['type'])
                offset = prop.get('offset', 0)
                decl = f"{cpp_type} {prop['name']};"
                padding = ' ' * (max_decl_len - len(decl) + 1)
                lines.append(f"    {decl}{padding}// +0x{offset:X}")
            lines.append("")
        
        # 方法
        if methods:
            lines.append("    // Methods")
            for m in sorted(methods, key=lambda x: x['name']):
                ret_type = get_cpp_type(m['return_type']) if m['has_return'] else "void"
                
                args = []
                for i, t in enumerate(m['arg_types']):
                    cpp_type = get_cpp_type(t)
                    if cpp_type not in ('void', 'bool', 'int64_t', 'double', 'Object*', 'RID'):
                        cpp_type = f"const {cpp_type}&"
                    args.append(f"{cpp_type} p_{i}")
                
                sig = "    "
                if m['is_static']:
                    sig += "static "
                sig += f"{ret_type} {m['name']}({', '.join(args)})"
                if m['is_const']:
                    sig += " const"
                sig += ";"
                lines.append(sig)
        
        lines.append("};")
        lines.append("")
    
    lines.append("} // namespace Godot")
    
    return '\n'.join(lines)
